#!/usr/bin/env python3
# Copyhigh (c) 2016-2017 The Bitcoin Core developers
# Distributed under the MIT software license, see the accompanying
# file COPYING or http://www.opensource.org/licenses/mit-license.php.
"""Test reconciliation-based transaction relay protocol.

"""

from test_framework.mininode import *
from test_framework.test_framework import BitcoinTestFramework
from test_framework.util import *
from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment
from test_framework.script import CScript, OP_TRUE, OP_DROP
from test_framework.messages import *
import hashlib
import random
from enum import IntEnum

MASK64 = 0xffffffffffffffff
MSG_WTX = 5


# These parameters are specified in the BIP-0330.
Q_PRECISION = 2 << 12
FIELD_BITS = 32
FIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101
BISEC_MEDIAN = 2 << 30

# These parameters are suggested by the Erlay paper based on analysis and simulations.
DEFAULT_Q = 0.01
RECON_REQUEST_INTERVAL = 16
MAX_OUTBOUND_FLOOD_TO = 8

def mul2(x):
    """Compute 2*x in GF(2^FIELD_BITS)"""
    return (x << 1) ^ (FIELD_MODULUS if x.bit_length() >= FIELD_BITS else 0)

def mul(x, y):
    """Compute x*y in GF(2^FIELD_BITS)"""
    ret = 0
    for bit in [(x >> i) & 1 for i in range(x.bit_length())]:
        ret, y = ret ^ bit * y, mul2(y)
    return ret

def create_sketch(shortids, capacity):
    """Compute the bytes of a sketch for given shortids and given capacity."""
    odd_sums = [0 for _ in range(capacity)]
    for shortid in shortids:
        squared = mul(shortid, shortid)
        for i in range(capacity):
            odd_sums[i] ^= shortid
            shortid = mul(shortid, squared)
    sketch_bytes = []
    for odd_sum in odd_sums:
        for i in range(4):
            sketch_bytes.append((odd_sum >> (i * 8)) & 0xff)
    return sketch_bytes


def generate_txs(n_local_unique, n_remote_unique, n_shared, blocks, test_framework, send=True):
    local_unique = []
    remote_unique = []
    shared = []

    for i in range(n_local_unique):
        tx = test_framework.generate_transaction(test_framework.nodes[0], blocks[test_framework.blocks_offset + i])
        local_unique.append(tx)

    for i in range(n_local_unique, n_local_unique + n_remote_unique):
        tx = test_framework.generate_transaction(test_framework.nodes[0], blocks[test_framework.blocks_offset + i])
        remote_unique.append(tx)

    for i in range(n_local_unique + n_remote_unique, n_local_unique + n_remote_unique + n_shared):
        tx = test_framework.generate_transaction(test_framework.nodes[0], blocks[test_framework.blocks_offset + i])
        shared.append(tx)

    if send:
        test_framework.nodes[0].p2p.send_txs_and_test(remote_unique + shared, test_framework.nodes[0], success = True)
        test_framework.blocks_offset += (n_local_unique + n_remote_unique + n_shared)
    return local_unique, remote_unique, shared


# TestP2PConn: A peer we use to send messages to bitcoind, and store responses.
class TestP2PConn(P2PDataStore):
    def __init__(self, recon_version, local_salt):
        super().__init__()
        self.recon_version = recon_version
        self.local_salt = local_salt
        self.remote_salt = 0
        self.last_sendrecon = []
        self.last_sketch = []
        self.last_inv = []
        self.last_tx = []
        self.last_reqreconcil = []
        self.last_reconcildiff = []
        self.last_reqbisec = []
        self.last_getdata = []
        self.remote_q = DEFAULT_Q
        self.last_wtxidrelay = []

    def on_sendrecon(self, message):
        self.last_sendrecon.append(message)
        self.remote_salt = message.salt

    def on_wtxidrelay(self, message):
        self.last_wtxidrelay.append(message)

    def on_sketch(self, message):
        self.last_sketch.append(message)

    def on_inv(self, message):
        MSG_BLOCK = 2 
        for inv in message.inv:
            if inv.type != MSG_BLOCK: # ignore block invs
                self.last_inv.append(inv.hash)

    def on_tx(self, message):
        self.last_tx.append(message.tx.calc_sha256(True))

    def on_reqrecon(self, message):
        self.last_reqreconcil.append(message)

    def on_reqbisec(self, message):
        self.last_reqbisec.append(message)

    def on_reconcildiff(self, message):
        self.last_reconcildiff.append(message)

    def send_wtxidrelay(self):
        msg = msg_wtxidrelay()
        self.send_message(msg)

    def send_recon(self, sender, responder):
        msg = msg_sendrecon()
        msg.salt = self.local_salt
        msg.version = self.recon_version
        msg.sender = sender
        msg.responder = responder
        self.send_message(msg)

    def send_reqrecon(self, set_size, q):
        msg = msg_reqrecon()
        msg.set_size = set_size
        msg.q = q
        self.send_message(msg)

    def send_sketch(self, skdata):
        msg = msg_sketch()
        msg.skdata = skdata
        self.send_message(msg)


    def send_reqbisec(self):
        msg = msg_reqbisec()
        self.send_message(msg)

    def send_reconcildiff(self, success, ask_shortids):
        msg = msg_reconcildiff()
        msg.success = success
        msg.ask_shortids = ask_shortids
        self.send_message(msg)

    def send_inv(self, inv_wtxids):
        msg = msg_inv(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in inv_wtxids])
        self.send_message(msg)

    def send_getdata(self, ask_wtxids):
        msg = msg_getdata(inv=[CInv(MSG_WTX, h=wtxid) for wtxid in ask_wtxids])
        self.send_message(msg)

class ReconResult(IntEnum):
    RECON_FAILED = 0
    RECON_LOW_FAILED = 1
    RECON_HIGH_FAILED = 2
    RECON_SUCCESS = 3

class ReconciliationTest(BitcoinTestFramework):
    def set_test_params(self):
        self.setup_clean_chain = True
        self.num_nodes = 1
        self.blocks_offset = 0

    def compute_full_salt(self):
        RECON_STATIC_SALT = "Tx Relay Salting"
        if self.test_node.remote_salt < self.test_node.local_salt:
            full_salt_str = "%s%d%d" % (RECON_STATIC_SALT, self.test_node.remote_salt, self.test_node.local_salt)
        else:
            full_salt_str = "%s%d%d" % (RECON_STATIC_SALT, self.test_node.local_salt, self.test_node.remote_salt)
        h = hashlib.sha256(full_salt_str.encode()).hexdigest()
        reversed_h = "" # TODO better way to handle endianness
        for i in range(0, 64, 2):
            reversed_h = h[i:i+2] + reversed_h
        h = int(reversed_h, 16)
        return h

    def generate_transaction(self, node, coinbase):
        amount = 0.001
        to_address = node.getnewaddress()
        from_txid = node.getblock(coinbase)['tx'][0]
        inputs = [{ "txid" : from_txid, "vout" : 0}]
        outputs = { to_address : amount }
        rawtx = node.createrawtransaction(inputs, outputs)
        signresult = node.signrawtransactionwithwallet(rawtx)
        tx = CTransaction()
        tx.deserialize(BytesIO(hex_str_to_bytes(signresult['hex'])))
        tx.rehash()
        return tx

    # - No reconciliation messages until sendrecon is sent.
    def test_sendrecon(self, test_node, sender, responder):
        test_node.send_wtxidrelay()
        def received_wtxidrelay():
            return (len(test_node.last_wtxidrelay) == 1)
        wait_until(received_wtxidrelay, timeout=30, lock=mininode_lock)

        def received_sendrecon():
            return (len(test_node.last_sendrecon) == 1)
        wait_until(received_sendrecon, timeout=30, lock=mininode_lock)

        with mininode_lock:
            assert_equal(test_node.last_sendrecon[0].version, test_node.recon_version)
            self.remote_salt = test_node.last_sendrecon[0].salt
            test_node.last_sendrecon = []
        test_node.send_recon(sender, responder)
    
    def test_request_reconcil(self, test_node, expected_sketch):
        local_set_size = 0
        q_to_send = int(DEFAULT_Q * Q_PRECISION)
        test_node.send_reqrecon(local_set_size, q_to_send)
        def received_sketch():
            return (len(test_node.last_sketch) == 1)
        wait_until(received_sketch, timeout=30, lock=mininode_lock)
        assert_equal(test_node.last_sketch[-1].skdata, expected_sketch)
        test_node.last_sketch = []

    def test_sendsketch(self, test_node, txs_to_sketch, bisection, capacity, expected_announced_txs):
        short_txids = [GetShortID(tx, self.compute_full_salt()) for tx in txs_to_sketch]
        if bisection:
            short_txids = [id for id in short_txids if id <= BISEC_MEDIAN]
        else:
            test_node.last_full_local_size = len(txs_to_sketch)
        sketch = create_sketch(short_txids, capacity)
        test_node.send_sketch(sketch)
        expected_wtxds = [tx.calc_sha256(True) for tx in expected_announced_txs]
        if len(expected_wtxds) > 0:
            def received_inv():
                return (len(test_node.last_inv) == len(expected_wtxds))
            wait_until(received_inv, timeout=30, lock=mininode_lock)
            assert_equal(set(test_node.last_inv), set(expected_wtxds))
            test_node.last_inv_size = len(test_node.last_inv) # Needed to recompute remote q later
            test_node.last_inv = []
        else:
            time.sleep(0.001)
            assert_equal(test_node.last_inv, [])

    def test_receive_reconcildiff(self, test_node, expected_success, expected_requested_txs, after_bisection=False):
        expected_requested_shortids = [GetShortID(tx, self.compute_full_salt()) for tx in expected_requested_txs]
        def received_reconcildiff():
            return (len(test_node.last_reconcildiff) == 1)
        wait_until(received_reconcildiff, timeout=30, lock=mininode_lock)
        success = test_node.last_reconcildiff[0].success
        assert_equal(success, int(expected_success))
        assert_equal(set(test_node.last_reconcildiff[0].ask_shortids), set(expected_requested_shortids))
        if success == ReconResult.RECON_SUCCESS:
            local_missing = test_node.last_inv_size
            remote_missing = len(test_node.last_reconcildiff[0].ask_shortids)
            total_missing = local_missing + remote_missing
            local_size = test_node.last_full_local_size
            remote_size = local_size + local_missing - remote_missing
            min_size = min(local_size, remote_size)
            if min_size != 0:
                test_node.remote_q = (total_missing - abs(local_missing - remote_missing)) / min_size
        else:
            if success == ReconResult.RECON_LOW_FAILED or success == ReconResult.RECON_HIGH_FAILED:
                test_node.remote_q *= 1.1
            else:
                # Full failure
                test_node.remote_q = DEFAULT_Q
        test_node.last_reconcildiff = []

    def test_receive_reqbisec(self, test_node):
        def received_reqbisec():
            return (len(test_node.last_reqbisec) == 1)
        wait_until(received_reqbisec, timeout=30, lock=mininode_lock)
        test_node.last_reqbisec = []


    def test_request_bisec(self, test_node, expected_bisec_sketch):
        test_node.send_reqbisec()
        def received_sketch():
            return (len(test_node.last_sketch) > 0)
        wait_until(received_sketch, timeout=30, lock=mininode_lock)
        assert_equal(len(test_node.last_sketch), 1)
        assert_equal(test_node.last_sketch[0].skdata, expected_bisec_sketch)
        test_node.last_sketch = []


    def test_send_reconcildiff(self, test_node, success, txs_to_request, txs_to_expect):
        ask_shortids = [GetShortID(tx, self.compute_full_salt()) for tx in txs_to_request]
        expected_wtxids = [tx.calc_sha256(with_witness = True) for tx in txs_to_expect]
        test_node.send_reconcildiff(success, ask_shortids)
        if txs_to_expect != []:
            def received_inv():
                return (len(test_node.last_inv) == len(txs_to_expect))
            wait_until(received_inv, timeout=30, lock=mininode_lock)
            assert_equal(set(test_node.last_inv), set(expected_wtxids))
            test_node.last_inv = []

    def test_sendgetdata(self, test_node, txs_to_request):
        assert_equal(test_node.last_tx, []) # Make sure there were no unexpected transactions received before
        wtxids_to_request = [tx.calc_sha256(with_witness = True) for tx in txs_to_request]
        test_node.send_getdata(wtxids_to_request)
        def received_tx():
            return (len(test_node.last_tx) == len(txs_to_request))
        wait_until(received_tx, timeout=30, lock=mininode_lock)
        assert_equal(set([tx.calc_sha256(True) for tx in txs_to_request]), set(test_node.last_tx))
        test_node.last_tx = []


    # The mininode is an inbound connection to the actual node being tested.
    # The mininode will initiate reconciliations. 
    def test_incoming_recon(self):
        LOCAL_SALT = random.randrange(0xffffff)
        self.blocks_offset = 0

        # Needed to submit txs
        self.test_node0 = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1, local_salt=LOCAL_SALT))
        self.test_node0.wait_for_verack()

        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1, local_salt=LOCAL_SALT))
        self.test_node.wait_for_verack()

        self.test_sendrecon(self.test_node, True, False)
        self.test_request_reconcil(self.test_node, expected_sketch=[])
        self.test_send_reconcildiff(self.test_node, success=ReconResult.RECON_SUCCESS, txs_to_request=[], txs_to_expect=[])

        blocks = self.nodes[0].generate(nblocks=1024)
        sync_blocks(self.nodes)

        # Initial reconciliation succeeds
        local_txs, remote_txs, _ = generate_txs(10, 20, 0, blocks, self)
        more_remote_txs = []
        expected_capacity = int(abs(len(remote_txs) - 0) + DEFAULT_Q * min(len(remote_txs), 0)) + 1
        remote_short_ids = [GetShortID(tx, self.compute_full_salt()) for tx in remote_txs]
        expected_sketch = create_sketch(remote_short_ids, expected_capacity)
        self.test_request_reconcil(self.test_node, expected_sketch)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        txs_to_request = random.sample(remote_txs, 3)
        self.test_send_reconcildiff(self.test_node, ReconResult.RECON_SUCCESS, txs_to_request, txs_to_expect=txs_to_request)
        self.test_sendgetdata(self.test_node, txs_to_request)
        self.check_remote_recon_set_incoming(more_remote_txs)
        more_remote_txs = []

        # Initial reconciliation fails, bisection succeeds
        _, remote_txs, _ = generate_txs(0, 20, 0, blocks, self)
        more_remote_txs = []
        expected_capacity = int(abs(len(remote_txs) - 0) + DEFAULT_Q * min(len(remote_txs), 0)) + 1
        remote_short_ids = [GetShortID(tx, self.compute_full_salt()) for tx in remote_txs]
        expected_sketch = create_sketch(remote_short_ids, expected_capacity)
        self.test_request_reconcil(self.test_node, expected_sketch)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        remote_low_short_ids = [id for id in remote_short_ids if id < (BISEC_MEDIAN)]
        expected_sketch = create_sketch(remote_low_short_ids, expected_capacity)
        self.test_request_bisec(self.test_node, expected_sketch)
        txs_to_request = random.sample(remote_txs, 3)
        self.test_send_reconcildiff(self.test_node, ReconResult.RECON_SUCCESS, txs_to_request, txs_to_expect=txs_to_request)
        self.test_sendgetdata(self.test_node, txs_to_request)
        self.check_remote_recon_set_incoming(more_remote_txs)

        # Initial reconciliation fails, bisection fails (both chunks)
        _, remote_txs, _ = generate_txs(0, 20, 0, blocks, self)
        more_remote_txs = []
        expected_capacity = int(abs(len(remote_txs) - 0) + DEFAULT_Q * min(len(remote_txs), 0)) + 1
        remote_short_ids = [GetShortID(tx, self.compute_full_salt()) for tx in remote_txs]
        expected_sketch = create_sketch(remote_short_ids, expected_capacity)
        self.test_request_reconcil(self.test_node, expected_sketch)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        remote_low_short_ids = [id for id in remote_short_ids if id < (BISEC_MEDIAN)]
        expected_sketch = create_sketch(remote_low_short_ids, expected_capacity)
        self.test_request_bisec(self.test_node, expected_sketch)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_send_reconcildiff(self.test_node, ReconResult.RECON_FAILED, txs_to_request=[], txs_to_expect=remote_txs)
        self.test_sendgetdata(self.test_node, remote_txs)
        self.check_remote_recon_set_incoming(more_remote_txs)

        # Initial reconciliation fails, bisection low chunk fails, bisection high chunk succeeds
        _, remote_txs, _ = generate_txs(0, 20, 0, blocks, self)
        more_remote_txs = []
        expected_capacity = int(abs(len(remote_txs) - 0) + DEFAULT_Q * min(len(remote_txs), 0)) + 1
        remote_short_ids = [GetShortID(tx, self.compute_full_salt()) for tx in remote_txs]
        expected_sketch = create_sketch(remote_short_ids, expected_capacity)
        self.test_request_reconcil(self.test_node, expected_sketch)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        remote_low_short_ids = [id for id in remote_short_ids if id < BISEC_MEDIAN]
        remote_high_short_ids = [id for id in remote_short_ids if id > BISEC_MEDIAN]
        expected_sketch = create_sketch(remote_low_short_ids, expected_capacity)
        self.test_request_bisec(self.test_node, expected_sketch)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        short_ids_to_request = [remote_high_short_ids[0]] # pretend that we have all but one txs from high chunk

        txs_to_request = []
        txs_to_expect = []
        for tx in remote_txs:
            short_id = GetShortID(tx, self.compute_full_salt())
            if short_id in short_ids_to_request:
                txs_to_request.append(tx)
                txs_to_expect.append(tx)
            if short_id in remote_low_short_ids:
                txs_to_expect.append(tx)

        self.test_send_reconcildiff(self.test_node, ReconResult.RECON_LOW_FAILED, txs_to_request, txs_to_expect)
        self.test_sendgetdata(self.test_node, txs_to_request)
        self.check_remote_recon_set_incoming(more_remote_txs)


        # Initial reconciliation fails, bisection low chunk succeeds, bisection high chunk fails
        _, remote_txs, _ = generate_txs(0, 20, 0, blocks, self)
        more_remote_txs = []
        expected_capacity = int(abs(len(remote_txs) - 0) + DEFAULT_Q * min(len(remote_txs), 0)) + 1
        remote_short_ids = [GetShortID(tx, self.compute_full_salt()) for tx in remote_txs]
        expected_sketch = create_sketch(remote_short_ids, expected_capacity)
        self.test_request_reconcil(self.test_node, expected_sketch)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        remote_low_short_ids = [id for id in remote_short_ids if id < (BISEC_MEDIAN)]
        remote_high_short_ids = [id for id in remote_short_ids if id > BISEC_MEDIAN]
        expected_sketch = create_sketch(remote_low_short_ids, expected_capacity)
        self.test_request_bisec(self.test_node, expected_sketch)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])        
        short_ids_to_request = [remote_low_short_ids[0]] # pretend that we have all but one txs from low chunk
        txs_to_request = []
        txs_to_expect = []
        for tx in remote_txs:
            short_id = GetShortID(tx, self.compute_full_salt())
            if short_id in short_ids_to_request:
                txs_to_request.append(tx)
                txs_to_expect.append(tx)
            if short_id in remote_high_short_ids:
                txs_to_expect.append(tx)

        self.test_send_reconcildiff(self.test_node, ReconResult.RECON_HIGH_FAILED, txs_to_request, txs_to_expect)
        self.test_sendgetdata(self.test_node, txs_to_request)
        self.check_remote_recon_set_incoming(more_remote_txs)
        
        # Initial reconciliation failed, bisection succeeded.
        # Peer received new transactions at some point during reconciliation.
        _, remote_txs, _ = generate_txs(0, 20, 0, blocks, self)
        more_remote_txs = []
        expected_capacity = int(abs(len(remote_txs) - 0) + DEFAULT_Q * min(len(remote_txs), 0)) + 1
        remote_short_ids = [GetShortID(tx, self.compute_full_salt()) for tx in remote_txs]
        expected_sketch = create_sketch(remote_short_ids, expected_capacity)
        self.test_request_reconcil(self.test_node, expected_sketch)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])        
        remote_low_short_ids = [id for id in remote_short_ids if id < (BISEC_MEDIAN)]
        expected_sketch = create_sketch(remote_low_short_ids, expected_capacity)
        self.test_request_bisec(self.test_node, expected_sketch)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])        
        self.test_send_reconcildiff(self.test_node, ReconResult.RECON_SUCCESS, txs_to_request=[], txs_to_expect=[])
        self.check_remote_recon_set_incoming(more_remote_txs)

    def check_remote_recon_set_incoming(self, txs_to_expect):
        expected_capacity = int(abs(len(txs_to_expect) - 0) + DEFAULT_Q * min(len(txs_to_expect), 0)) + 1
        short_ids = [GetShortID(tx, self.compute_full_salt()) for tx in txs_to_expect]
        expected_sketch = create_sketch(short_ids, expected_capacity)
        self.test_request_reconcil(self.test_node, expected_sketch)
        self.test_send_reconcildiff(self.test_node, success=ReconResult.RECON_SUCCESS, txs_to_request=[], txs_to_expect=[])



    def test_incoming_reqreconcil(self, test_node, expected_set_size):
        def received_reqreconcil():
            return (len(test_node.last_reqreconcil) == 1)
        wait_until(received_reqreconcil, timeout=30, lock=mininode_lock)
        assert_equal(test_node.last_reqreconcil[-1].set_size, expected_set_size)
        assert_equal(test_node.last_reqreconcil[-1].q, int(test_node.remote_q * Q_PRECISION))
        test_node.last_reqreconcil = []

    # Mininode is an outgoing connection to the actual node being tested.
    # The actual node will initiate reconciliations.
    def test_outgoing_recon(self):
        LOCAL_SALT = random.randrange(0xffffff)
        self.blocks_offset = 0
        # These nodes will consume regular tx flood forwarding 
        for i in range(MAX_OUTBOUND_FLOOD_TO):
            flooding_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1, local_salt=LOCAL_SALT), node_outgoing=True)
            flooding_node.wait_for_verack()

        time.sleep(1)

        self.test_node = self.nodes[0].add_p2p_connection(TestP2PConn(recon_version=1, local_salt=LOCAL_SALT), node_outgoing=True)
        self.test_node.wait_for_verack()

        blocks = self.nodes[0].generate(nblocks=1024)
        sync_blocks(self.nodes)

        self.mocktime = int(time.time())
        self.nodes[0].setmocktime(self.mocktime)

        self.test_sendrecon(self.test_node, False, True)
        self.check_remote_recon_set_outgoing([])

        # 20 on their side, 20 on our side, 10 shared, initial reconciliation succeeds
        local_unique_txs, remote_unique_txs, shared_txs = generate_txs(20, 20, 10, blocks, self)
        local_txs = local_unique_txs + shared_txs
        remote_txs = remote_unique_txs + shared_txs
        more_remote_txs = []
        # Currently sometimes reconciliation request comes empty in this particular place.
        # There should be some way to "align" the timer so that a node have time to include transactions in
        # the reconciliation set before it requests reconciliation from the mininode.
        self.mocktime += 5
        self.nodes[0].setmocktime(self.mocktime)
        self.mocktime += RECON_REQUEST_INTERVAL + 1
        self.nodes[0].setmocktime(self.mocktime)
        self.test_incoming_reqreconcil(self.test_node, expected_set_size=len(remote_txs))
        self.test_sendsketch(self.test_node, txs_to_sketch=local_txs, bisection=False,
            capacity=51, expected_announced_txs=remote_unique_txs)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_receive_reconcildiff(self.test_node, expected_success=ReconResult.RECON_SUCCESS,
            expected_requested_txs=local_unique_txs, after_bisection=False)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendgetdata(self.test_node, remote_unique_txs)
        self.check_remote_recon_set_outgoing(more_remote_txs)

        # 20 on their side, 20 on our side, 10 shared, initial reconciliation fails, bisection succeeds
        local_unique_txs, remote_unique_txs, shared_txs = generate_txs(20, 20, 10, blocks, self)
        local_txs = local_unique_txs + shared_txs
        remote_txs = remote_unique_txs + shared_txs
        more_remote_txs = []
        self.mocktime += RECON_REQUEST_INTERVAL + 1
        self.nodes[0].setmocktime(self.mocktime)
        self.test_incoming_reqreconcil(self.test_node, expected_set_size=len(remote_txs))
        self.test_sendsketch(self.test_node, txs_to_sketch=local_txs, bisection=False,
            capacity=30, expected_announced_txs=[])
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_receive_reqbisec(self.test_node)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendsketch(self.test_node, txs_to_sketch=local_txs, bisection=True,
            capacity=30, expected_announced_txs=remote_unique_txs)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_receive_reconcildiff(self.test_node, expected_success=ReconResult.RECON_SUCCESS,
            expected_requested_txs=local_unique_txs, after_bisection=True)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendgetdata(self.test_node, remote_unique_txs)
        self.check_remote_recon_set_outgoing(more_remote_txs)

        # 20 their side, 20 on our side, 10 shared, initial reconciliation fails, bisection fails (both chunks)
        local_unique_txs, remote_unique_txs, shared_txs = generate_txs(20, 20, 10, blocks, self)
        local_txs = local_unique_txs + shared_txs
        remote_txs = remote_unique_txs + shared_txs
        more_remote_txs = []
        self.mocktime += RECON_REQUEST_INTERVAL + 1
        self.nodes[0].setmocktime(self.mocktime)

        self.test_incoming_reqreconcil(self.test_node, expected_set_size=len(remote_txs))
        self.test_sendsketch(self.test_node, txs_to_sketch=local_txs, bisection=False,
            capacity=10, expected_announced_txs=[])
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_receive_reqbisec(self.test_node)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendsketch(self.test_node, txs_to_sketch=local_txs, bisection=True,
            capacity=10, expected_announced_txs=remote_txs)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_receive_reconcildiff(self.test_node, expected_success=ReconResult.RECON_FAILED,
            expected_requested_txs=[], after_bisection=True)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendgetdata(self.test_node, remote_unique_txs)
        self.check_remote_recon_set_outgoing(more_remote_txs)

        # 30 on their side, 30 on our side, initial sketch is not enough to decode, low bisection fails, high bisection succeeds
        # Emulating the case when low chunk diff is bigger due to the non-uniform distributions
        local_txs, remote_txs, _ = generate_txs(10, 30, 0, blocks, self, send=False)
        while len(local_txs) != 30:
            tx = generate_txs(1, 0, 0, blocks, self, send=False)[0][0]
            if GetShortID(tx, self.compute_full_salt()) < BISEC_MEDIAN:
                local_txs.append(tx)
        more_remote_txs = []
        self.blocks_offset += 60
        self.nodes[0].p2p.send_txs_and_test(remote_txs, self.nodes[0], success = True)
        self.mocktime += RECON_REQUEST_INTERVAL + 1
        self.nodes[0].setmocktime(self.mocktime)
        self.test_incoming_reqreconcil(self.test_node, expected_set_size=len(remote_txs))
        self.test_sendsketch(self.test_node, txs_to_sketch=local_txs, bisection=False,
            capacity=30, expected_announced_txs=[])
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_receive_reqbisec(self.test_node)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendsketch(self.test_node, txs_to_sketch=local_txs, bisection=True,
            capacity=30, expected_announced_txs=remote_txs)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        local_high_txs = [tx for tx in local_txs if GetShortID(tx, self.compute_full_salt()) > BISEC_MEDIAN]
        self.test_receive_reconcildiff(self.test_node, expected_success=ReconResult.RECON_LOW_FAILED,
            expected_requested_txs=local_high_txs, after_bisection=True)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendgetdata(self.test_node, remote_txs)
        self.check_remote_recon_set_outgoing(more_remote_txs)

        # 30 on their side, 30 on our side, initial sketch is not enough to decode, low bisection succeeds, high bisection fails
        # Emulating the case when high chunk diff is bigger due to the non-uniform distribution
        local_txs, remote_txs, _ = generate_txs(10, 30, 0, blocks, self, send=False)
        while len(local_txs) != 30:
            tx = generate_txs(1, 0, 0, blocks, self, send=False)[0][0]
            if GetShortID(tx, self.compute_full_salt()) >= BISEC_MEDIAN:
                local_txs.append(tx)
        more_remote_txs = []
        self.blocks_offset += 60
        self.nodes[0].p2p.send_txs_and_test(remote_txs, self.nodes[0], success = True)
        self.mocktime += RECON_REQUEST_INTERVAL + 1
        self.nodes[0].setmocktime(self.mocktime)
        self.test_incoming_reqreconcil(self.test_node, expected_set_size=len(remote_txs))
        self.test_sendsketch(self.test_node, txs_to_sketch=local_txs, bisection=False,
            capacity=30, expected_announced_txs=[])
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_receive_reqbisec(self.test_node)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendsketch(self.test_node, txs_to_sketch=local_txs, bisection=True,
            capacity=30, expected_announced_txs=remote_txs)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        local_low_txs = [tx for tx in local_txs if GetShortID(tx, self.compute_full_salt()) <= BISEC_MEDIAN]
        self.test_receive_reconcildiff(self.test_node, expected_success=ReconResult.RECON_HIGH_FAILED,
            expected_requested_txs=local_low_txs, after_bisection=True)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendgetdata(self.test_node, remote_txs)
        self.check_remote_recon_set_outgoing(more_remote_txs)

        ## Transactions are not lost if empty sketch is sent initially
        _, remote_txs, _ = generate_txs(0, 5, 0, blocks, self)
        self.mocktime += RECON_REQUEST_INTERVAL + 1
        self.nodes[0].setmocktime(self.mocktime)
        self.test_incoming_reqreconcil(self.test_node, expected_set_size=len(remote_txs))
        remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendsketch(self.test_node, txs_to_sketch=[], bisection=False,
            capacity=0, expected_announced_txs=remote_txs)
        self.test_receive_reconcildiff(self.test_node, expected_success=ReconResult.RECON_FAILED,
            expected_requested_txs=[], after_bisection=False)
        self.check_remote_recon_set_outgoing([])

        ## Transactions are not lost if empty sketch is sent during bisection
        local_txs, remote_txs, _ = generate_txs(5, 5, 0, blocks, self)
        more_remote_txs = []
        self.mocktime += RECON_REQUEST_INTERVAL + 1
        self.nodes[0].setmocktime(self.mocktime)
        self.test_incoming_reqreconcil(self.test_node, expected_set_size=len(remote_txs))
        remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendsketch(self.test_node, txs_to_sketch=local_txs, bisection=False,
            capacity=5, expected_announced_txs=[])
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_receive_reqbisec(self.test_node)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_sendsketch(self.test_node, txs_to_sketch=[], bisection=True, capacity=0,
            expected_announced_txs=remote_txs)
        more_remote_txs.extend(generate_txs(0, 1, 0, blocks, self)[1])
        self.test_receive_reconcildiff(self.test_node, expected_success=ReconResult.RECON_FAILED,
            expected_requested_txs=[], after_bisection=True)
        self.check_remote_recon_set_outgoing(more_remote_txs)

        return

    def check_remote_recon_set_outgoing(self, txs_to_expect):
        self.mocktime += RECON_REQUEST_INTERVAL + 1
        self.nodes[0].setmocktime(self.mocktime)
        self.test_incoming_reqreconcil(self.test_node, expected_set_size=len(txs_to_expect))
        self.test_sendsketch(self.test_node, txs_to_sketch=[], bisection=False, capacity=0, expected_announced_txs=txs_to_expect)
        self.test_receive_reconcildiff(self.test_node, expected_success=ReconResult.RECON_FAILED,
            expected_requested_txs=[], after_bisection=False)


    def run_test(self):
        # We inject more_remote_txs in all tests to make sure that 
        # new transactions are not lost across reconciliation rounds.
        self.test_incoming_recon()
        self.restart_node(0)
        self.test_outgoing_recon()

def GetShortID(tx, full_salt):
    k0 = full_salt & MASK64
    k1 = (full_salt >> 64) & MASK64
    wtxid = tx.calc_sha256(with_witness = True)
    s = siphash256(k0, k1, wtxid)
    return 1 + (s & 0xFFFFFFFF)


if __name__ == '__main__':
    ReconciliationTest().main()
